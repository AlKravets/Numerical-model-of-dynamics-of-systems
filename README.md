# Лабораторные работы по предмету "Численное моделирование динамики систем"

- [Лабораторные работы по предмету "Численное моделирование динамики систем"](#лабораторные-работы-по-предмету-численное-моделирование-динамики-систем)
  - [Лабораторная №1 "Численное моделирования для уравнения теплопроводности"](#лабораторная-1-численное-моделирования-для-уравнения-теплопроводности)
    - [Постановка задачи](#постановка-задачи)
    - [Использование программы](#использование-программы)
      - [Создание методов](#создание-методов)
      - [Рисунки](#рисунки)
  - [Лабораторная №2 "Численное решение уравнения Бюргерса"](#лабораторная-2-численное-решение-уравнения-бюргерса)

## Лабораторная №1 "Численное моделирования для уравнения теплопроводности"

- [Код работы](lab1/main.py)
- [Отчет pdf](lab1/report/report.pdf)
- [Отчет tex](lab1/report/report.tex)

### Постановка задачи

Было дано уравнение теплопроводности с двумя пространственными переменными и краевыми условиями первого рода. Необходимо было реализовать 3 разностных алгоритма:
1. явная разностная схема
2. метод переменных направлений
3. двухшаговый симметризированный алгоритм

Также были даны аналитические решения уравнения теплопроводности. Необходимо было при помощи данного аналитического решения вычислить правую часть уравнения теплопроводности. А после, получив численное приближение решения, вычислить абсолютную ошибку.

### Использование программы

Основные параметры задаются в блоке, что идет после `if __name__ =="__main__":`

Вот пример параметров
<!-- Cspell:disable -->
```py
    x_lim = [0,1]
    y_lim = [0,1]
    h = 0.1

    t_0 = 0
    tau = h**2/4
    t = t_0

    steps = 100

    params = {
        'a':0.1,
        'A': 1,
        'k1':1,
        'k2':1,
    }
```
<!-- Cspell:enable -->

здесь:

- `x_lim`, `y_lim` - ограничения по соответствующим координатам.
- `h` - шаг разностной схемы по пространству. Он един для оси x и оси y
- `t_0` - начальное значение времени
- `tau` - шаг разностной схемы по времени. В примере он задан так, чтобы явная разностная схема была стойкой
- `steps` - количество шагов разностной схемы
- `t` - параметр, который отображает текущее время для разностной схемы


Нужно задать аналитическое решение и аналитически вычисленную правую часть. Вот пример для варианта 1.

<!-- Cspell:disable -->
```py
def analytical_solution_1(x,y,t, **params):
    """
    Это аналитаческое решение (w) для вар 1
    в функцию по своему желанию можно передавать именованные параметры 
    a="value",
    A="value",
    k1="value",
    k2="value"
    если ничего не передано,то идет значения по умолчанию: все равны 1
    """
    a = params.get("a") or 1
    A = params.get("A") or 1
    k1 = params.get("k1") or 1
    k2 = params.get("k2") or 1
    
    return A*np.exp(k1*x + k2*y + (k1**2 + k2**2)*a*t)
    
def analytical_f_1(x,y,t,**params):
    """
    Аналитически вычисленная правая часть по аналитическому решению
    В случае вар. 1 это просто 0
    """
    a = params.get("a") or 1
    A = params.get("A") or 1
    k1 = params.get("k1") or 1
    k2 = params.get("k2") or 1
    return np.zeros(x.shape)
```
<!-- Cspell:enable -->

Функции принимают `x`, `y` и `t`. Причем `x`, `y` - это numpy-массивы, а `t` - это число. `params` - это константные параметры для функций.

В основном блоке есть словарь `params` в котором перечисленны параметры для функций. 

#### Создание методов

В этом блоке кода показано, как создаются методы

<!-- Cspell:disable -->
```py
cond= BoundaryConditions_first_type(x_lim,y_lim,t_0, analytical_solution_1, **params)

x= np.arange(*x_lim, step =h)[1:]
y= np.arange(*y_lim, step =h)[1:]

method1 = MethodExplicitDifferenceScheme(x,y,cond, h, tau, analytical_f_1, **params )
method2 = AlternatingDirectionMethod(x,y,cond, h, tau, analytical_f_1, **params)
method3 = Double_strandedSymmetrizedAlgorithm(x,y,cond, h, tau, analytical_f_1, **params)

# список методов, которые для которых будет вычислена ошибка
method_list = [method1,method2, method3]
```
<!-- Cspell:enable -->

1. В начале создается объект, который отвечает за краевые условия: `BoundaryConditions_first_type`
2. Создаются массивы `x`,`y`, по которым будет строится сетка разностных методов. Стоит заметить, что `x`,`y` не включат крайних точек, это сделано, потому что разностная сетка строится по тим точкам, а крайние точки считаются в `BoundaryConditions_first_type`.
3. Создается объект явной разностной схемы (`MethodExplicitDifferenceScheme`).
4. Создается объект метода переменных направлений (`AlternatingDirectionMethod`)
5. Создается объект двухшагового симметризированного алгоритма (`Double_strandedSymmetrizedAlgorithm`)

У объектов методов есть 2 метода:
- `__call__` (вызов метода как функцию). Возвращает сетку значений разностной схемы на текущем шаге.
- `update`. Обновление разностной схемы (шаг по времени).

***
**В списке `method_list` записаны те методы, которые будут запущены.** Из него можно убирать методы и добавлять. Для тестов можно увеличить параметр `tau`, что испортит стойкость явной разностной схемы, тогда можно просто убрать этот метод из списка и программа запустит только остальные два.
***

#### Рисунки

Программа делает 3 графика. 
- график абсолютной ошибки
- график абсолютной ошибки с логарифмической шкалой по оси ошибки
- график аналитического решения в конечный момент времени.

Вот код, что это делает
<!-- Cspell:disable -->
```py
error_graphic(time_list, methods_error_list, title= "Абсолютна похибка")
error_graphic(time_list, methods_error_list, title= "Абсолютна похибка log шкала", log_scale=True)

solution_graphic(xv,yv,[analytical_solution_1(xv,yv,t, **params)], title="Аналітичний розв'язок")
plt.show()
```
<!-- Cspell:enable -->

Функция `error_graphic` принимает список временных отметок и список списков с абсолютными ошибками методов. По умолчанию методы нумеруются начиная с 1, но можно ввести свои обозначения (параметр функции `methods_labels`).


## Лабораторная №2 "Численное решение уравнения Бюргерса"

Пока код [тут](lab2/main.py).